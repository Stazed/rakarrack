/* tuneit.c -- Detect fundamental frequency of a sound
 * Copyright (C) 2004, 2005  Mario Lang <mlang@delysid.org>
 *
 * Modified for rakarrack by Josep Andreu
 * MIDIConverter.C  MIDI Converter class
 * This is free software, placed under the terms of the
 * GNU General Public License, as published by the Free Software Foundation.
 * Please see the file COPYING for details.
 */
#include "MIDIConverter.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "global.h"

#define M_PI 3.14159265358979323846
#define MAX_FFT_LENGTH 48000
#define MAX_PEAKS 8


MIDIConverter::MIDIConverter (char *jname, RKR *_rkr, double sample_rate, uint32_t intermediate_bufsize)
{
    rkr = _rkr;     // for jack midi event write
    SAMPLE_RATE = sample_rate;
    fSAMPLE_RATE = (float)sample_rate;
    PERIOD = intermediate_bufsize;  // correct for rakarrack, may be adjusted by lv2

    Input_Gain = 0.50f;
    Pfft = 0;
    velocity = 100;
    channel = 0;
    lanota = -1;
    preparada = 0;
    nota_actual = -1;
    TrigVal = .25f;
    hay = 0;    // This is used for the red light on/off display
    ponla = 0;
    Moctave = 0;
    
    Pgain = 64;              // lv2 only
    Pmidi = 0;
    Poctave = 0;
    Ppanic = 0;
    Pvelocity = 0;
    Ptrigger = 0;
    Pfft = 0;

    schmittBuffer = NULL;
    schmittPointer = NULL;
    static const char *englishNotes[12] =
    { "A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#" };
    notes = englishNotes;
    note = 0;
    nfreq = 0;
    afreq = 0;

    fftFrameCount = 0;

    schmittInit (32); // 32 == latency (tuneit default = 10)
    fftInit (32);     // == latency

#ifdef LV2RUN
    dSAMPLE_RATE = sample_rate;
    Plpf = 3000;
    Phpf = 300;
    VAL_SUM = -50.0f;
    old_il_sum = -50.0f;
    old_ir_sum = -50.0f;
    val_il_sum = -50.0;
    val_ir_sum = -50.0;
    update_freqs(440.0f);
    initialize();
    setlpf(3000);       // Voice
    sethpf(300);        // Voice
#else
    // Open Alsa Seq
    int err = snd_seq_open (&port, "default", SND_SEQ_OPEN_OUTPUT, 0);
    if (err < 0)
        printf ("Cannot activate ALSA seq client\n");
    snd_seq_set_client_name (port, jname);
    snd_config_update_free_global ();

    char portname[50];

    // Create Alsa Seq Client

    sprintf (portname, "%s MC OUT",jname);
    snd_seq_create_simple_port (port, portname,
    SND_SEQ_PORT_CAP_READ |
    SND_SEQ_PORT_CAP_SUBS_READ,
    SND_SEQ_PORT_TYPE_APPLICATION);
#endif // LV2RUN

};


MIDIConverter::~MIDIConverter ()
{
    schmittFree();
    fftFree();
#ifdef LV2RUN
    clear_initialize();
#else
    snd_seq_close (port);
#endif // LV2RUN
}

#ifdef LV2RUN
void
MIDIConverter::out(float * efxoutl, float * efxoutr)
{

    float il_sum = 1e-12f;
    float ir_sum = 1e-12f;
    float temp_sum;
    float tmp;

    float Log_I_Gain;
    Log_I_Gain = powf (Input_Gain * 2.0f, 4);


    for (unsigned i = 0; i < PERIOD; i++) {
        efxoutl[i] *= Log_I_Gain;
        efxoutr[i] *= Log_I_Gain;
        tmp = fabsf(efxoutr[i]);
        if (tmp > ir_sum) ir_sum = tmp;
        tmp = fabsf(efxoutl[i]);
        if (tmp > il_sum) il_sum = tmp;
    }

    if (val_il_sum != old_il_sum) {
        old_il_sum=val_il_sum;
    }

    if (val_ir_sum != old_ir_sum) {
        old_ir_sum=val_ir_sum;
    }

    temp_sum = (float)CLAMP (rap2dB (il_sum), -48.0, 15.0);
    val_il_sum = .6f * old_il_sum + .4f * temp_sum;

    temp_sum = (float)CLAMP (rap2dB (ir_sum), -48.0, 15.0);
    val_ir_sum = .6f * old_ir_sum + .4f * temp_sum;

    VAL_SUM = val_il_sum + val_ir_sum;

    if(Pfft)
        fftFloat(efxoutl,efxoutr, VAL_SUM, FREQS, LFREQS);
    else
        schmittFloat(efxoutl,efxoutr, VAL_SUM, FREQS, LFREQS);

}
#endif // LV2RUN

void
MIDIConverter::cleanup()
{
    // nothing
}

#ifdef LV2RUN
void
MIDIConverter::lv2_update_params(uint32_t period)
{
    if(period > PERIOD) // only re-initialize if period > intermediate_bufsize of declaration
    {
        PERIOD = period;
        clear_initialize();
        initialize();
        setlpf(3000);       // Voice
        sethpf(300);        // Voice
    }
    else
    {
        PERIOD = period;
    }
}
#endif // LV2RUN

void
MIDIConverter::displayFrequency (float ffreq, float val_sum, float *freqs, float *lfreqs)
{
    int i;
    int noteoff = 0;
    int octave = 4;

    float ldf, mldf;
    float lfreq;

    if (ffreq < 1E-15)
        ffreq = 1E-15f;
    lfreq = logf (ffreq);
    while (lfreq < lfreqs[0] - LOG_D_NOTE * .5f)
        lfreq += LOG_2;
    while (lfreq >= lfreqs[0] + LOG_2 - LOG_D_NOTE * .5f)
        lfreq -= LOG_2;
    mldf = LOG_D_NOTE;
    for (i = 0; i < 12; i++) {
        ldf = fabsf (lfreq - lfreqs[i]);
        if (ldf < mldf) {
            mldf = ldf;
            note = i;
        }
    }
    nfreq = freqs[note];
    while (nfreq / ffreq > D_NOTE_SQRT) {
        nfreq *= .5f;
        octave--;
        if (octave < -2) {
            noteoff = 1;
            break;
        }

    }
    while (ffreq / nfreq > D_NOTE_SQRT) {
        nfreq *= 2.0f;
        octave++;
        if (octave > 9) {
            noteoff = 1;
            break;
        }
    }


    cents = lrintf (1200.0f * (logf (ffreq / nfreq) / LOG_2));
    lanota = 24 + (octave * 12) + note - 3;


    if ((noteoff) & (hay)) {
        MIDI_Send_Note_Off (nota_actual);
        hay = 0;
        nota_actual = -1;
    }

    if ((preparada == lanota) && (lanota != nota_actual)) {

        hay = 1;
        if (nota_actual != -1) {
            MIDI_Send_Note_Off (nota_actual);
        }

        MIDI_Send_Note_On (lanota, val_sum);
        nota_actual = lanota;
    }  
    
    if ((lanota > 0 && lanota < 128) && (lanota != nota_actual))
        preparada = lanota;

};

void
MIDIConverter::schmittInit (int size)
{
    blockSize = SAMPLE_RATE / size;
    schmittBuffer =
        (signed short int *) malloc (sizeof (signed short int) * (blockSize + 2));  // +2 because valgrind bitches about invalid reads in schmittS16LE()
    
    memset (schmittBuffer, 0, sizeof (signed short int) * (blockSize + 2));
    schmittPointer = schmittBuffer;
};

void
MIDIConverter::schmittS16LE (signed short int *indata, float val_sum, float *freqs, float *lfreqs)
{
    unsigned int i, j;
    float trigfact = 0.6f;

    for (i = 0; i < PERIOD; i++) {
        *schmittPointer++ = indata[i];
        if (schmittPointer - schmittBuffer >= blockSize) {
            int endpoint, startpoint, t1, t2, A1, A2, tc, schmittTriggered;

            schmittPointer = schmittBuffer;

            for (j = 0, A1 = 0, A2 = 0; j < blockSize; j++) {
                if (schmittBuffer[j] > 0 && A1 < schmittBuffer[j])
                    A1 = schmittBuffer[j];
                if (schmittBuffer[j] < 0 && A2 < -schmittBuffer[j])
                    A2 = -schmittBuffer[j];
            }
            t1 = lrintf ((float)A1 * trigfact + 0.5f);
            t2 = -lrintf ((float)A2 * trigfact + 0.5f);
            startpoint = 0;
            for (j = 1; schmittBuffer[j] <= t1 && j < blockSize; j++);
            for (; !(schmittBuffer[j] >= t2 &&
                     schmittBuffer[j + 1] < t2) && j < blockSize; j++);
            startpoint = j;
            schmittTriggered = 0;
            endpoint = startpoint + 1;
            for (j = startpoint, tc = 0; j < blockSize; j++) {
                if (!schmittTriggered) {
                    schmittTriggered = (schmittBuffer[j] >= t1);
                } else if (schmittBuffer[j] >= t2 && schmittBuffer[j + 1] < t2) {
                    endpoint = j;
                    tc++;
                    schmittTriggered = 0;
                }
            }
            if (endpoint > startpoint) {
                afreq =
                    fSAMPLE_RATE *((float)tc / (float) (endpoint - startpoint));
                displayFrequency (afreq, val_sum, freqs, lfreqs);

            }
        }
    }
};

void
MIDIConverter::schmittFree ()
{
    free (schmittBuffer);
};

void
MIDIConverter::schmittFloat (float * efxoutl, float * efxoutr, float val_sum, float *freqs, float *lfreqs)
{
    unsigned int i;
#ifdef LV2RUN
    lpfl->filterout (efxoutl, PERIOD);
    hpfl->filterout (efxoutl, PERIOD);
    lpfr->filterout (efxoutr, PERIOD);
    hpfr->filterout (efxoutr, PERIOD);
#endif // LV2RUN
    signed short int buf[PERIOD];
    for (i = 0; i < PERIOD; i++) {
        buf[i] =
            (short) ((TrigVal * efxoutl[i] + TrigVal * efxoutr[i]) * 32768);
    }
    schmittS16LE (buf, val_sum, freqs, lfreqs);
};


void
MIDIConverter::fftInit (int size)
{

    fftSize = SAMPLE_RATE/size;
    fftIn = (float*) fftwf_malloc(sizeof(float) * 2 * (fftSize/2+1));
    fftOut = (fftwf_complex *)fftIn;
    fftPlan = fftwf_plan_dft_r2c_1d(fftSize, fftIn, fftOut, FFTW_MEASURE);

    fftSampleBuffer = (float *)malloc(fftSize * sizeof(float));
    fftSample = NULL;
    fftLastPhase = (float *)malloc((fftSize/2+1) * sizeof(float));
    memset(fftSampleBuffer, 0, fftSize*sizeof(float));
    memset(fftLastPhase, 0, (fftSize/2+1)*sizeof(float));
}

void
MIDIConverter::fftMeasure (int overlap, float *indata, float val_sum, float *freqs, float *lfreqs)
{
    int stepSize = fftSize/overlap;
    double freqPerBin = SAMPLE_RATE/(double)fftSize,
           phaseDifference = 2.*M_PI*(double)stepSize/(double)fftSize;

    if (!fftSample) fftSample = fftSampleBuffer + (fftSize-stepSize);

    for (unsigned int i=0; i<PERIOD; i++) {
        *fftSample++ = indata[i];
        if (fftSample-fftSampleBuffer >= fftSize) {
            int k;
            Peak peaks[MAX_PEAKS];

            for (k=0; k<MAX_PEAKS; k++) {
                peaks[k].db = -200.;
                peaks[k].freq = 0.;
            }

            fftSample = fftSampleBuffer + (fftSize-stepSize);

            for (k=0; k<fftSize; k++) {
                double window = -.5*cos(2.*M_PI*(double)k/(double)fftSize)+.5;
                fftIn[k] = fftSampleBuffer[k] * window;
            }
            fftwf_execute(fftPlan);

            for (k=0; k<=fftSize/2; k++) {
                long qpd;
                float
                real = creal(fftOut[k]),        // This requires -std=gnu++98 
                imag = cimag(fftOut[k]),        // This requires -std=gnu++98 
                magnitude = 20.*log10(2.*sqrt(real*real + imag*imag)/fftSize),
                phase = atan2(imag, real),
                tmp, freq;

                /* compute phase difference */
                tmp = phase - fftLastPhase[k];
                fftLastPhase[k] = phase;

                /* subtract expected phase difference */
                tmp -= (double)k*phaseDifference;

                /* map delta phase into +/- Pi interval */
                qpd = tmp / M_PI;
                if (qpd >= 0) qpd += qpd&1;
                else qpd -= qpd&1;
                tmp -= M_PI*(double)qpd;

                /* get deviation from bin frequency from the +/- Pi interval */
                tmp = overlap*tmp/(2.*M_PI);

                /* compute the k-th partials' true frequency */
                freq = (double)k*freqPerBin + tmp*freqPerBin;

                if (freq > 0.0 && magnitude > peaks[0].db) {
                    memmove(peaks+1, peaks, sizeof(Peak)*(MAX_PEAKS-1));
                    peaks[0].freq = freq;
                    peaks[0].db = magnitude;
                }
            }
            fftFrameCount++;
            if (fftFrameCount > 0 && fftFrameCount % overlap == 0) {
                int l, maxharm = 0;
                k = 0;
                for (l=1; l<MAX_PEAKS && peaks[l].freq > 0.0; l++) {
                    int harmonic;

                    for (harmonic=5; harmonic>1; harmonic--) {
                        if (peaks[0].freq / peaks[l].freq < harmonic+.02 &&
                                peaks[0].freq / peaks[l].freq > harmonic-.02) {
                            if (harmonic > maxharm &&
                                    peaks[0].db < peaks[l].db/2) {
                                maxharm = harmonic;
                                k = l;
                            }
                        }
                    }
                }
                displayFrequency(peaks[k].freq, val_sum, freqs, lfreqs);
            }
            memmove(fftSampleBuffer, fftSampleBuffer+stepSize, (fftSize-stepSize)*sizeof(float));
        }
    }
}

void
MIDIConverter::fftFloat (float *efxoutl, float *efxoutr, float val_sum, float *freqs, float *lfreqs)
{
#ifdef LV2RUN
    lpfl->filterout (efxoutl, PERIOD);
    hpfl->filterout (efxoutl, PERIOD);
    lpfr->filterout (efxoutr, PERIOD);
    hpfr->filterout (efxoutr, PERIOD);
#endif // LV2RUN
    
    signed short int buf[PERIOD];
    for (unsigned int i = 0; i < PERIOD; i++) {
        buf[i] =
            (short) ((TrigVal * efxoutl[i] + TrigVal * efxoutr[i]) * 32768);
    }
    fftS16LE(buf, val_sum, freqs, lfreqs);
}

void
MIDIConverter::fftS16LE (signed short int *indata, float val_sum, float *freqs, float *lfreqs)
{
    float buf[PERIOD];

    for (unsigned int i=0; i<PERIOD; i++) {
        buf[i] = indata[i]/32768.;
    }
    fftMeasure(4, buf, val_sum, freqs, lfreqs);
}

void
MIDIConverter::fftFree ()
{
    fftwf_destroy_plan(fftPlan);
    fftwf_free(fftIn);
    free(fftSampleBuffer);
    free(fftLastPhase);
}


void
MIDIConverter::MIDI_Send_Note_On (int nota, float val_sum)
{
    int k;

    const uint8_t anota = (uint8_t) nota + ( Moctave * 12) ;
    if(anota>127) return;

    k = lrintf ((val_sum + 96) * 2);

    if (k > 127)
        k = 127;
    if (k < 1)
        k = 1;

    velocity = lrintf((float)k / VelVal);

#ifdef LV2RUN
    midi_ON_msg[0]=LV2_MIDI_MSG_NOTE_ON + channel;
    midi_ON_msg[1]=anota;
    midi_ON_msg[2]=velocity;

    forge_midimessage(plug,0, midi_ON_msg,3);

#else
    // ALSA
    snd_seq_event_t ev;
    snd_seq_ev_clear (&ev);
    snd_seq_ev_set_noteon (&ev,channel,anota,velocity);
    snd_seq_ev_set_subs (&ev);
    snd_seq_ev_set_direct (&ev);
    snd_seq_event_output_direct (port, &ev);

    // JACK
 
    int moutdatasize = 0;
    moutdata_ON[moutdatasize]=144+channel;
    moutdatasize++;
    moutdata_ON[moutdatasize]=anota;
    moutdatasize++;
    moutdata_ON[moutdatasize]=velocity;
    moutdatasize++;
    
    Midi_event_ON[0].dataloc=moutdata_ON;
    Midi_event_ON[0].time=0;
    Midi_event_ON[0].len=3;
    
    dataout_ON = rkr->dataout;  // dataout = jack_port_get_buffer(jack_midi_out, nframes);
 
    jack_midi_event_write(dataout_ON,
                              Midi_event_ON[0].time,
                              Midi_event_ON[0].dataloc,
                              Midi_event_ON[0].len);
    
#endif // LV2RUN

};


void
MIDIConverter::MIDI_Send_Note_Off (int nota)
{
    const uint8_t anota = (uint8_t) nota + ( Moctave * 12) ;
    if(anota>127) return;

#ifdef LV2RUN
    midi_OFF_msg[0]=LV2_MIDI_MSG_NOTE_OFF + channel;
    midi_OFF_msg[1]=anota;
    midi_OFF_msg[2]=64;   // velocity

    forge_midimessage(plug,0, midi_OFF_msg,3);

#else
    // ALSA
    snd_seq_event_t ev;
    snd_seq_ev_clear (&ev);
    snd_seq_ev_set_noteoff (&ev, channel, anota, 0);
    snd_seq_ev_set_subs (&ev);
    snd_seq_ev_set_direct (&ev);
    snd_seq_event_output_direct (port, &ev);

    // JACK
    int moutdatasize = 0;
    
    moutdata_OFF[moutdatasize]=128+channel;
    moutdatasize++;
    moutdata_OFF[moutdatasize]=anota;
    moutdatasize++;
    moutdata_OFF[moutdatasize]=64;
    moutdatasize++;
    
    Midi_event_OFF[0].dataloc=moutdata_OFF;
    Midi_event_OFF[0].time=0;
    Midi_event_OFF[0].len=3;
    
    dataout_OFF = rkr->dataout; // dataout = jack_port_get_buffer(jack_midi_out, nframes);
    
    jack_midi_event_write(dataout_OFF,
                              Midi_event_OFF[0].time,
                              Midi_event_OFF[0].dataloc,
                              Midi_event_OFF[0].len);
    
#endif // LV2RUN
};


void
MIDIConverter::setGain(int value)
{
    Input_Gain=(float)((value+50)/100.0);       // lv2 only
}

void
MIDIConverter::panic ()
{
    int i;

    for (i = 0; i < 127; i++)
        MIDI_Send_Note_Off (i);
    hay = 0;
    nota_actual = -1;
}


void
MIDIConverter::setmidichannel (int chan)
{
    channel = chan;
};


void
MIDIConverter::setTriggerAdjust (int val)
{
    TrigVal = 1.0f / (float)val;
};


void
MIDIConverter::setVelAdjust (int val)
{
    VelVal = 100.0f / (float)val;
};

void
MIDIConverter::setOctAdjust(int val)
{
    Moctave = val;
}

void
MIDIConverter::changepar (int npar, int value)
{
    switch (npar) {
    case 0:
        Pgain = value;      // lv2 only
        setGain(value);
        break;
    case 1:
        Ptrigger = value;
        setTriggerAdjust(value);
        break;
    case 2:
        Pvelocity = value;
        setVelAdjust(value);
        break;
    case 3:
        Pmidi = value;
        setmidichannel(value-1); // offset
        break;
    case 4:
        Poctave = value;
        setOctAdjust(value);
        break;
    case 5:
        Pfft = value;
        break;
    case 6:
        Ppanic = value;
        panic();
        break;
#ifdef LV2RUN
    case 7:
        Plpf = value;
        setlpf(value);
        break;
    case 8:
        Phpf = value;
        sethpf(value);
        break;
#endif // LV2RUN
    };
};

int
MIDIConverter::getpar (int npar)
{
    switch (npar) {
    case 0:
        return (Pgain);     // lv2 only
        break;
    case 1:
        return (Ptrigger);
        break;
    case 2:
        return (Pvelocity);
        break;
    case 3:
        return (Pmidi);
        break;
    case 4:
        return (Poctave);
        break;
    case 5:
        return (Pfft);
        break;
    case 6:
        return (Ppanic);
        break;
#ifdef LV2RUN
    case 7:
        return (Plpf);
        break;
    case 8:
        return (Phpf);
        break;
#endif // LV2RUN
    default:
        return (0);
    };

};

#ifdef LV2RUN
void
MIDIConverter::update_freqs(float val) // val = 440.0f - user default settings
{
    int i;

    float aFreq=val;

    FREQS[0] = aFreq;
    LFREQS[0] = logf (FREQS[0]);
    for (i = 1; i < 12; i++) {
        FREQS[i] = FREQS[i - 1] * D_NOTE;
        LFREQS[i] = LFREQS[i - 1] + LOG_D_NOTE;
    }
}

void MIDIConverter::initialize()
{
    interpbuf = new float[PERIOD];
    lpfl = new AnalogFilter (2, 3000, 1, 0, dSAMPLE_RATE, interpbuf);
    lpfr = new AnalogFilter (2, 3000, 1, 0, dSAMPLE_RATE, interpbuf);
    hpfl = new AnalogFilter (3, 300, 1, 0, dSAMPLE_RATE, interpbuf);
    hpfr = new AnalogFilter (3, 300, 1, 0, dSAMPLE_RATE, interpbuf);
}

void MIDIConverter::clear_initialize()
{
    delete lpfl;
    delete lpfr;
    delete hpfl;
    delete hpfr;
    delete[] interpbuf;
}

void
MIDIConverter::setlpf (int value)
{
    float fr = (float)value;
    lpfl->setfreq (fr);
    lpfr->setfreq (fr);
};

void
MIDIConverter::sethpf (int value)
{
    float fr = (float)value;

    hpfl->setfreq (fr);
    hpfr->setfreq (fr);


}

#endif // LV2RUN